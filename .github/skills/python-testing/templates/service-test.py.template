"""
Service layer tests for ${ServiceName}.

Services orchestrate business logic and coordinate between repositories.
Test business rules and service coordination, not repository implementation.
"""
import pytest
from unittest.mock import Mock, AsyncMock, patch

from services.${service_module} import ${ServiceName}
from repositories.${repository_module} import ${RepositoryName}


class Test${ServiceName}:
    """Test suite for ${ServiceName}."""

    @pytest.fixture
    def mock_repository(self):
        """Mock repository dependency."""
        mock = Mock(spec=${RepositoryName})
        return mock

    @pytest.fixture
    def mock_external_service(self):
        """Mock external service dependency."""
        mock = Mock()
        return mock

    @pytest.fixture
    def service(self, mock_repository, mock_external_service):
        """Create service instance with mocked dependencies."""
        return ${ServiceName}(
            repository=mock_repository,
            external_service=mock_external_service
        )

    def test_${operation}_success(self, service, mock_repository):
        """Test successful ${operation} returns expected result."""
        # Arrange
        input_data = {"key": "value"}
        expected_result = {"id": "123", "status": "success"}
        mock_repository.${method}.return_value = expected_result

        # Act
        result = service.${operation}(input_data)

        # Assert
        assert result == expected_result
        mock_repository.${method}.assert_called_once_with(input_data)

    def test_${operation}_validates_input(self, service):
        """Test ${operation} validates required input fields."""
        # Arrange
        invalid_input = {}  # Missing required fields

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            service.${operation}(invalid_input)
        
        assert "validation error message" in str(exc_info.value)

    def test_${operation}_handles_repository_error(self, service, mock_repository):
        """Test ${operation} handles repository errors gracefully."""
        # Arrange
        mock_repository.${method}.side_effect = Exception("Database error")

        # Act & Assert
        with pytest.raises(${ServiceError}) as exc_info:
            service.${operation}({"key": "value"})
        
        assert "service error message" in str(exc_info.value)

    def test_${operation}_coordinates_multiple_calls(
        self, service, mock_repository, mock_external_service
    ):
        """Test ${operation} coordinates multiple repository/service calls."""
        # Arrange
        mock_repository.find.return_value = {"id": "123"}
        mock_external_service.process.return_value = {"status": "processed"}
        mock_repository.update.return_value = {"id": "123", "updated": True}

        # Act
        result = service.${operation}("123")

        # Assert
        assert result["updated"] is True
        mock_repository.find.assert_called_once_with("123")
        mock_external_service.process.assert_called_once()
        mock_repository.update.assert_called_once()

    def test_${operation}_handles_not_found(self, service, mock_repository):
        """Test ${operation} handles resource not found."""
        # Arrange
        mock_repository.find.return_value = None

        # Act & Assert
        with pytest.raises(${NotFoundError}):
            service.${operation}("nonexistent-id")

    def test_${operation}_applies_business_rules(self, service, mock_repository):
        """Test ${operation} applies correct business rules."""
        # Arrange
        input_data = {"amount": 100, "currency": "USD"}
        
        # Act
        service.${operation}(input_data)

        # Assert - Verify business rule was applied
        call_args = mock_repository.${method}.call_args[0][0]
        assert call_args["amount"] == 100
        assert call_args["fee"] == 5  # 5% fee applied
        assert call_args["total"] == 105
